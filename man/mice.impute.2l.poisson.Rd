% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mice.impute.2l.poisson.R
\name{mice.impute.2l.poisson}
\alias{mice.impute.2l.poisson}
\alias{mice.impute.2l.poisson.boot}
\alias{mice.impute.2l.poisson.noint}
\alias{mice.impute.2l.poisson.noint.boot}
\alias{mice.impute.2l.poisson.noint}
\alias{mice.impute.2l.poisson.boot}
\alias{mice.impute.2l.poisson.noint.boot}
\alias{mice.impute.2l.nb}
\alias{mice.impute.2l.nb.noint}
\alias{mice.impute.2l.nb.boot}
\alias{mice.impute.2l.nb.noint.boot}
\alias{mice.impute.2l.nb2}
\alias{mice.impute.2l.nb2.noint}
\alias{mice.impute.2l.nb2.boot}
\alias{mice.impute.2l.nb2.noint.boot}
\title{Multiple Imputation of Incomplete Two-Level Count Data}
\usage{
mice.impute.2l.poisson(y, ry, x, type, intercept = TRUE, wy = NULL,
  EV = TRUE)

mice.impute.2l.poisson.noint(y, ry, x, type, intercept = FALSE, wy = NULL,
  EV = TRUE)

mice.impute.2l.poisson.boot(y, ry, x, type, intercept = TRUE, wy = NULL,
  EV = TRUE)

mice.impute.2l.poisson.noint.boot(y, ry, x, type, intercept = FALSE,
  wy = NULL, EV = TRUE)

mice.impute.2l.nb(y, ry, x, type, intercept = TRUE, wy = NULL, EV = TRUE)

mice.impute.2l.nb.noint(y, ry, x, type, intercept = FALSE, wy = NULL,
  EV = TRUE)

mice.impute.2l.nb.boot(y, ry, x, type, intercept = TRUE, wy = NULL,
  EV = TRUE)

mice.impute.2l.nb.noint.boot(y, ry, x, type, intercept = FALSE, wy = NULL,
  EV = TRUE)

mice.impute.2l.nb2(y, ry, x, type, intercept = TRUE, wy = NULL, EV = TRUE)

mice.impute.2l.nb2.noint(y, ry, x, type, intercept = FALSE, wy = NULL,
  EV = TRUE)

mice.impute.2l.nb2.boot(y, ry, x, type, intercept = TRUE, wy = NULL,
  EV = TRUE)

mice.impute.2l.nb2.noint.boot(y, ry, x, type, intercept = FALSE, wy = NULL,
  EV = TRUE)
}
\arguments{
\item{y}{Numeric vector with incomplete data in long format (i.e. the groups are stacked upon each other)}

\item{ry}{Response pattern of \code{y} (\code{TRUE}=observed, \code{FALSE}=missing)}

\item{x}{matrix with \code{length(y)} rows containing complete covariates; also in long format}

\item{type}{vector of length \code{ncol(x)} identifying fixed, random, and class variables; \code{type} is automatically extracted from the \code{predictorMatrix}; see \pkg{mice}'s user's manual for details about how to specify the imputation model; see also section ``details''.}

\item{intercept}{\code{TRUE}: model will include intercept as a random effect; \code{FALSE}: intercept will be treated as fixed.}

\item{wy}{Logical vector of length \code{length(y)}. A \code{TRUE} value indicates locations in \code{y} for which imputations are created. Default is \code{!ry}}

\item{EV}{should automatic outlier handling of imputed values be enabled?  Default is \code{TRUE}: extreme imputations will be identified. These values will be replaced by imputations obtained by predictive mean matching (function \code{mice.impute.midastouch()})}
}
\value{
Numeric vector of length \code{sum(!ry)} with imputations
}
\description{
The functions impute multilevel count data based on a two-level Poisson or negative binomial model, either using a Bayesian regression or a bootstrap regression approach (appendix: ``\code{.boot}''). The \code{.noint} variants treat the intercept only as a fixed, but \emph{not} as a random effect. Package \pkg{glmmTMB} is used to fit the model.
}
\details{
Model specification details:
   \itemize{
     \item -2 = class variable (only one class variable is allowed!)
     \item 0 = variable not included in imputation model
     \item 1 = variable will be included as a fixed effect 
     \item 2 = variable will be included as a fixed \emph{and} random effect 
   }
The Bayesian regression variants (see Rubin 1987, p. 169-170) consist of the following steps:
 \enumerate{
 \item Fit the model; find bhat, the posterior mean, and V(bhat), the posterior variance of model parameters b
 \item Draw b* from N(bhat,V(bhat))
 \item Obtain fitted values based on b*
 \item Draw imputations for the incomplete part from appropriate distribution (Poisson or NB)
 }
The bootstrap functions draw a bootstrap sample from \code{y[ry]} and \code{x[ry,]} (Note: we resample clusters rather than individual cases) and consist of the following steps:
\enumerate{
\item Fit the model to the bootstrap sample
 \item Obtain fitted values
 \item Draw imputations for the incomplete part from appropriate distribution (Poisson or NB)
}
}
\section{Functions}{
\itemize{
\item \code{mice.impute.2l.poisson}: Bayesian Poisson regression variant; random intercept

\item \code{mice.impute.2l.poisson.noint}: Bayesian NB regression variant; fixed intercept

\item \code{mice.impute.2l.poisson.boot}: Bootstrap NB regression variant; random intercept

\item \code{mice.impute.2l.poisson.noint.boot}: Bootstrap NB regression variant; fixed intercept

\item \code{mice.impute.2l.nb}: Bayesian NB regression variant; random intercept

\item \code{mice.impute.2l.nb.noint}: Bayesian NB regression variant; fixed intercept

\item \code{mice.impute.2l.nb.boot}: Bootstrap NB regression variant; random intercept

\item \code{mice.impute.2l.nb.noint.boot}: Bootstrap NB regression variant; fixed intercept

\item \code{mice.impute.2l.nb2}: identical to \code{mice.impute.2l.nb}; kept for backward compatibility

\item \code{mice.impute.2l.nb2.noint}: identical to \code{mice.impute.2l.nb.noint}; kept for backward compatibility

\item \code{mice.impute.2l.nb2.boot}: identical to \code{mice.impute.2l.nb.boot}; kept for backward compatibility

\item \code{mice.impute.2l.nb2.noint.boot}: identical to \code{mice.impute.2l.nb.noint.boot}; kept for backward compatibility
}}

\author{
Kristian Kleinke
}
