% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mice.impute.2l.hnb.R
\name{mice.impute.2l.hnb}
\alias{mice.impute.2l.hnb}
\alias{mice.impute.2l.hnb.boot}
\alias{mice.impute.2l.hnb.noint.both}
\alias{mice.impute.2l.hnb.noint.both.boot}
\alias{mice.impute.2l.hnb.noint.zero}
\alias{mice.impute.2l.hnb.noint.zero.boot}
\alias{mice.impute.2l.hnb.noint.count}
\alias{mice.impute.2l.hnb.noint.count.boot}
\alias{mice.impute.2l.hnb.boot}
\alias{mice.impute.2l.hnb.noint.both.boot}
\alias{mice.impute.2l.hnb.noint.both}
\alias{mice.impute.2l.hnb.noint.count.boot}
\alias{mice.impute.2l.hnb.noint.count}
\alias{mice.impute.2l.hnb.noint.zero.boot}
\alias{mice.impute.2l.hnb.noint.zero}
\alias{mice.impute.2l.hp}
\alias{mice.impute.2l.hp.boot}
\alias{mice.impute.2l.hp.noint.both.boot}
\alias{mice.impute.2l.hp.noint.both}
\alias{mice.impute.2l.hp.noint.count.boot}
\alias{mice.impute.2l.hp.noint.count}
\alias{mice.impute.2l.hp.noint.zero.boot}
\alias{mice.impute.2l.hp.noint.zero}
\title{Multiple Imputation of Zero-Inflated Two-Level Count Data}
\usage{
mice.impute.2l.hnb(y, ry, x, type, intercept.c = TRUE, intercept.z = TRUE,
  wy = NULL, EV = TRUE)

mice.impute.2l.hnb.boot(y, ry, x, type, intercept.c = TRUE,
  intercept.z = TRUE, wy = NULL, EV = TRUE)

mice.impute.2l.hnb.noint.both.boot(y, ry, x, type, intercept.c = FALSE,
  intercept.z = FALSE, wy = NULL, EV = TRUE)

mice.impute.2l.hnb.noint.both(y, ry, x, type, intercept.c = FALSE,
  intercept.z = FALSE, wy = NULL, EV = TRUE)

mice.impute.2l.hnb.noint.count.boot(y, ry, x, type, intercept.c = FALSE,
  intercept.z = TRUE, wy = NULL, EV = TRUE)

mice.impute.2l.hnb.noint.count(y, ry, x, type, intercept.c = FALSE,
  intercept.z = TRUE, wy = NULL, EV = TRUE)

mice.impute.2l.hnb.noint.zero.boot(y, ry, x, type, intercept.c = TRUE,
  intercept.z = FALSE, wy = NULL, EV = TRUE)

mice.impute.2l.hnb.noint.zero(y, ry, x, type, intercept.c = TRUE,
  intercept.z = FALSE, wy = NULL, EV = TRUE)

mice.impute.2l.hp(y, ry, x, type, intercept.c = TRUE, intercept.z = TRUE,
  wy = NULL, EV = TRUE)

mice.impute.2l.hp.boot(y, ry, x, type, intercept.c = TRUE,
  intercept.z = TRUE, wy = NULL, EV = TRUE)

mice.impute.2l.hp.noint.both.boot(y, ry, x, type, intercept.c = FALSE,
  intercept.z = FALSE, wy = NULL, EV = TRUE)

mice.impute.2l.hp.noint.both(y, ry, x, type, intercept.c = FALSE,
  intercept.z = FALSE, wy = NULL, EV = TRUE)

mice.impute.2l.hp.noint.count.boot(y, ry, x, type, intercept.c = FALSE,
  intercept.z = TRUE, wy = NULL, EV = TRUE)

mice.impute.2l.hp.noint.count(y, ry, x, type, intercept.c = FALSE,
  intercept.z = TRUE, wy = NULL, EV = TRUE)

mice.impute.2l.hp.noint.zero.boot(y, ry, x, type, intercept.c = TRUE,
  intercept.z = FALSE, wy = NULL, EV = TRUE)

mice.impute.2l.hp.noint.zero(y, ry, x, type, intercept.c = TRUE,
  intercept.z = FALSE, wy = NULL, EV = TRUE)
}
\arguments{
\item{y}{Numeric vector with incomplete data in long format (i.e. the groups are stacked upon each other)}

\item{ry}{Response pattern of \code{y} (\code{TRUE}=observed, \code{FALSE}=missing)}

\item{x}{matrix with \code{length(y)} rows containing complete covariates; also in long format}

\item{type}{vector of length \code{ncol(x)} identifying fixed, random, and class variables; \code{type} is automatically extracted from the \code{predictorMatrix}; see \pkg{mice}'s user's manual for details about how to specify the imputation model; see also section ``details''.}

\item{intercept.c}{\code{TRUE}: model will include intercept as a random effect in the count model; \code{FALSE}: count model intercept will be treated as fixed.}

\item{intercept.z}{\code{TRUE}: model will include intercept as a random effect in the zero model; \code{FALSE}: zero model intercept will be treated as fixed.}

\item{wy}{Logical vector of length \code{length(y)}. A \code{TRUE} value indicates locations in \code{y} for which imputations are created. Default is \code{!ry}}

\item{EV}{should automatic outlier handling of imputed values be enabled?  Default is \code{TRUE}: extreme imputations will be identified. These values will be replaced by imputations obtained by predictive mean matching (function \code{mice.impute.midastouch()})}
}
\value{
Numeric vector of length \code{sum(!ry)} with imputations
}
\description{
The functions impute zero-inflated multilevel count data based on a two-level Poisson or negative binomial hurdle model, either using a Bayesian regression or a bootstrap regression approach (appendix: ``\code{.boot}''). The \code{.noint} variants treat the intercept only as a fixed, but \emph{not} as a random effect. It may be specified, if the intercept is excluded from the random part of the zero model (``\code{.noint.zero}''), the count model (``\code{.noint.count}''), or both models (``\code{.noint.both}''). Hurdle models are mixture models and consist of two model components: the zero model (a binomial generalized linear mixed effects model), determining, if the observational unit has a zero or non-zero value, and the count model (a zero-truncated two-level Poisson or NB model), determining, what non-zero value the observational unit has.
}
\details{
Model specification details:
   \itemize{
     \item -2 = class variable (only one class variable is allowed!)
     \item 0 = variable not included in imputation model
     \item 1 = variable will be included as a fixed effect (zero \emph{and} count model)
     \item 2 = variable will be included as a fixed \emph{and} random effect (zero \emph{and} count model)
     \item 3 = variable will be included as a fixed effect (count model only)
     \item 4 = variable will be included as a fixed \emph{and} random effect (count model only)
     \item 5 = variable will be included as a fixed effect (zero model only)
     \item 6 = variable will be included as a fixed \emph{and} random effect (zero model only)
   }
The Bayesian regression variants (see Rubin 1987, p. 169-170) consist of the following steps:
 \enumerate{
 \item Fit the zero model (a two-level binomial generalized linear mixed effects model), using the \code{glmmTMB} function from package \pkg{glmmTMB}; find bhat, the posterior mean, and V(bhat), the posterior variance of model parameters b
 \item Draw b* from N(bhat,V(bhat))
 \item Compute predicted probabilities for having a zero vs. non-zero count
 \item Draw imputations (zeros and ones) from a binomial distribution with the respective individual probabilities obtained from step 3.
 \item Fit the count model (a zero-truncated two-level Poisson or NB model) using the \code{glmmTMB} function from package \pkg{glmmTMB}; find bhat, the posterior mean, and V(bhat), the posterior variance of model parameters b.
 \item  Draw b* from N(bhat,V(bhat))
 \item Compute predicted values using parameters b* and replace non-zero imputations (from step 4) by a draw from a zero-truncated NB distribution with mean parameter mu being the count predicted for the respective incomplete case.
 }
The bootstrap functions draw a bootstrap sample from \code{y[ry]} and \code{x[ry,]} (Note: we resample clusters rather than individual cases) and consist of the following steps:
\enumerate{
\item Fit the zero model to the bootstrap sample
\item Compute predicted probabilities for having a zero vs. non-zero count
\item Draw imputations from a binomial distribution.
\item Fit the count model to the boostrap sample
\item Compute predicted counts and draw non-zero imputations (from step 3) from a zero-truncated Poisson or NB distribution.
}
}
\section{Functions}{
\itemize{
\item \code{mice.impute.2l.hnb}: Bayesian regression variant; random intercepts

\item \code{mice.impute.2l.hnb.boot}: bootstrap regression variant; random intercepts

\item \code{mice.impute.2l.hnb.noint.both.boot}: bootstrap regression variant; fixed intercepts

\item \code{mice.impute.2l.hnb.noint.both}: Bayesian regression variant; fixed intercepts

\item \code{mice.impute.2l.hnb.noint.count.boot}: bootstrap regression variant; fixed intercept in count model

\item \code{mice.impute.2l.hnb.noint.count}: Bayesian regression variant; fixed intercept in count model

\item \code{mice.impute.2l.hnb.noint.zero.boot}: bootstrap regression variant; fixed interceot in zero model

\item \code{mice.impute.2l.hnb.noint.zero}: Bayesian regression variant; fixed intercept in zero model

\item \code{mice.impute.2l.hp}: Bayesian regression variant; random intercepts

\item \code{mice.impute.2l.hp.boot}: bootstrap regression variant; random intercepts

\item \code{mice.impute.2l.hp.noint.both.boot}: bootstrap regression variant; fixed intercepts

\item \code{mice.impute.2l.hp.noint.both}: Bayesian regression variant; fixed intercepts

\item \code{mice.impute.2l.hp.noint.count.boot}: bootstrap regression variant; fixed intercept in count model

\item \code{mice.impute.2l.hp.noint.count}: Bayesian regression variant; fixed intercept in count model

\item \code{mice.impute.2l.hp.noint.zero.boot}: bootstrap regression variant; fixed interceot in zero model

\item \code{mice.impute.2l.hp.noint.zero}: Bayesian regression variant; fixed intercept in zero model
}}

\author{
Kristian Kleinke
}
